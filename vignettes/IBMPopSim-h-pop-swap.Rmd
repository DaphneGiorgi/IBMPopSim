---
title: "Human population with swap"
author:
    - Daphné Giorgi
    - Sarah Kaakaï
    - Vincent Lemaire
output:
    #rmarkdown::html_vignette:
    #rmarkdown::html_document:
    BiocStyle::html_document:
        toc: true
        toc_depth: 2
        toc_float: true
        #number_sections: true
    #prettydoc::html_pretty:
    #theme: cayman
    #highlight: github
package: IBMPopSim
mathjax: "//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
vignette: >
  %\VignetteIndexEntry{Human population with internal and external migration}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
library(IBMPopSim)
library(ggfortify)
library(gridExtra)
knitr::opts_chunk$set(echo = TRUE)
```

This document provides an example of usage of the package IBMPopSim, for simulating a human population with IMD swaps.

# Example description
The human population has 2 genders, male and female, and is distributed into 5 IMD (Index of Multiple Deprivation).

The population is age-structured.

Swaps can occour, making an individual to change IMD, which correspond for example to a young peorson around 25 moving from its original rich neighbourhood and going to live in a student neighbourhood, or to a 35 person which started to earn more money and can afford a richer neighbourhood.

# Population creation

The package contains the pyramid of ages of England's population for the year 2014.

```{r}
str(EW_popIMD_14)
```

The `population_from_population` function creates a population of size `pop_size` based on an starting population.

```{r}
head(EW_popIMD_14$sample)
#pop_size <- 1e6

#population <- sample_from_population(EW_popIMD_2014$population, pop_size)

#population$male <- as.logical(population$male)
#population$IMD <- as.integer(population$IMD)

#head(population)
```

# Events description
There are 3 possible events :

- Birth
- Death
- Swap

Each event is caracterised by its intensity and its kernel, as follows.

## Birth

We assume that the birth event is an individual event with Weibull intensities depending on the IMD of the individual who gives birth and on a constant named TFR. We can also add some weights to rise up and down the intensities depending on the IMD.
The IMD of the new individual is inherited from the parent and the sex is attributed depending on a proportion given by the birth sex ratio.



### Parameters

```{r}
birth_sex_ratio = 1.05
params_birth <- with(EW_popIMD_14$rates$birth_params,
    list(
        "TFR_weights" = TFR_weights,
        "age_min" = 25,
        "birth" =     list(
            weibull(beta[1], alpha[1]),
            weibull(beta[2], alpha[2]),
            weibull(beta[3], alpha[3])
        ),
        "p_male" = birth_sex_ratio/(1+birth_sex_ratio)
    )
)
```

### Event creation


Give the C++ code of the intensity of a birth event:

```{r}
birth_intensity_code <- '
    if (I.male) result = 0.;
    else {
        if (I.IMD <= 2) result = TFR_weights[0] * birth[0](age(I,t)-age_min);
        if (I.IMD == 3) result = TFR_weights[1] * birth[1](age(I,t)-age_min);
        if (I.IMD >= 4) result = TFR_weights[2] * birth[2](age(I,t)-age_min);
    }
'
```

Create the birth event
```{r}
birth_event <- mk_event_individual(
    type = "birth", name = "birth",
    intensity_code = birth_intensity_code,
    kernel_code = "newI.male = CUnif(0, 1) < p_male;"
)
```


## Death
We assume that the death event is an individual event with intensities given by 10 step functions, depending on the IMD and on the sex of the individual.
These are functions of age and time.


### Parameters

```{r}
params_death = with(EW_popIMD_14$rates,
    list(
        "death_male" = lapply(seq(1,5), function(i) stepfun(x=seq(1,130), y=t(subset(death_male, IMD==i, "value")))),
        "death_female" = lapply(seq(1,5), function(i) stepfun(x=seq(1,130), y=t(subset(death_female, IMD==i, "value"))))
    )
)
```

```{r}
params_death$death_male
```

```{r}
myplots <- list()

for (i in 1:5){
    p <- autoplot(params_death$death_male[[i]], shape = NULL) +
        labs(x="Age", y="Intensity") +
        ggtitle("") +
        theme(plot.title = element_text(hjust = 0.5))
    myplots[[i]] <- p
}

do.call("grid.arrange", c(myplots, ncol=5))
```

Give the c++ code of the intensity of a death event:
```{r}
intensity_code_death <- '
    if (I.male)
        result = death_male[(I.IMD-1)](age(I,t));
    else
        result = death_female[(I.IMD-1)](age(I,t));
'
```


Create the death event:
```{r}
death_event <- mk_event_individual(
    type = "death", name = "death",
    intensity_code = intensity_code_death
)
```

## Swap

We assume that the swap event is an individual event, where the intensities are given by 5 step functions, depending on the IMD of the individual. They are functions of age and time.
When a swap event occur, the new IMD is chosen depending on a probability which depends on the age of the individual.
These probabilities are given by the matrix `EW_popIMD_14$swap_distribution`,

```{r}
params_swap <- with(EW_popIMD_14$rates$swap,
    list(
        "swap_intensities" = apply(intensities, 2, function(rates) stepfun(x=ages, y=rates)),
        "swap_distribution" = as.matrix(distribution),
        "swap_age_to_idx" = stepfun(ages, seq(0,3))
    )
)
```

Give the c++ code of the intensity of a swap event:
```{r}
intensity_code_swap <- '
    result = swap_intensities[I.IMD-1](age(I,t));
'
```

Give the c++ code of the kernel of a swap event:
```{r}
kernel_code_swap <- '
    I.IMD = CDiscrete(swap_distribution.begin_row(swap_age_to_idx(age(I,t))),
                      swap_distribution.end_row(swap_age_to_idx(age(I,t)))) + 1;
'
```

Create the swap event:

```{r}
swap_event <- mk_event_individual(
    type = "swap", name = "swap",
    intensity_code = intensity_code_swap,
    kernel_code = kernel_code_swap
)
```


# List R parameters and functions available in c++
In order to be able to use the R parameters and functions in the c++ code, we have to pass them to the model, hence we prepare a parameters object that we will use in the construction of the model and for launching the simulations.

```{r}
params = c(params_birth, params_death, params_swap)
```

```{r}
age_max <- 130
```

Compute the bound of the intensities for a birth event.

```{r}
E <- c(0, age_max) - params$age_min
birth_max <- with(params, max(
    TFR_weights[1] * optimize(f=birth[[1]], interval=E, maximum=TRUE)$objective,
    TFR_weights[2] * optimize(f=birth[[2]], interval=E, maximum=TRUE)$objective,
    TFR_weights[3] * optimize(f=birth[[3]], interval=E, maximum=TRUE)$objective))
```

The bound of the intensities for an death event is:
```{r}
death_max <- max(sapply(params$death_male, max),
                 sapply(params$death_female, max))
```

Compute the bound of the intensities for an swap event.
```{r fig.align="center"}
swap_max <- max(sapply(params$swap_intensities, max))
```


# Build model

Build the model:

```{r}
model <- mk_model(
    characteristics = get_characteristics(EW_popIMD_14$sample),
    events = list(birth_event, death_event, swap_event),
    parameters = params
)

summary(model)
```

# Run simulation

Run the simulation:

```{r}
start_time <- Sys.time()
sim_out <- popsim(model,
    population = EW_popIMD_14$sample,
    events_bounds = c(birth_max, death_max, swap_max),
    parameters = params,
    age_max = 130,
    times = seq(0,10),
    multithreading=TRUE)

end_time <- Sys.time()
difftime(end_time, start_time, units="secs")
```

```{r}
str(sim_out)
```

```{r}
max(sim_out[[10]]$id)
```

```{r}
library(dplyr)
l = sim_out[[11]]
for (k in 10:2)
l <- left_join(l,
           subset(sim_out[[k-1]], select=c("id", "IMD")),
           by="id", suffix = c(as.character(k),as.character(k-1)))

```

```{r}
tail(l, n = 1000)
```
